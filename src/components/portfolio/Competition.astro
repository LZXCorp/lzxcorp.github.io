---
import Heading from "../ui/Heading.astro";
import { Icon } from "astro-icon/components";

const COMPETITION = [
  {
    title: "The InfoSecurity Challenge (TISC) 2025",
    description: "Completed 8 / 12 challenges. Ranked 44th overall.",
    issuer: "Centre for Strategic Infocomm Technologies (CSIT)",
    logo: "/images/logos/csit-logo.png",
    more: "/blog/posts/tisc2025-writeup1",
    badgeicon: "https://cdn.certifier.io/6c98c6a3-c4c8-4acc-9d72-1954f2445f98/credentials/01k8a2cweqsh1g3zxmcnkqnje0/designs/01k8a29h2qz0k6t6g6h2k0resv/6CwcD-uVzf.png",
    badgelink: "https://credsverse.com/credentials/d963e812-b2bb-40ef-8c23-7e1c56ff18da",
    obtained: "10-2025",
    accent: "rgb(255 90 0)",
    tags: [
      "CTF", "Cloud Security", "Web Exploitation", "Rev"
    ],
  },
  {
    title: "GCTF 2024",
    description: "Participated in the Gryphons CTF 2024 and completed around 20+ challenges.",
    issuer: "Gryphons",
    logo: "/images/logos/gryphons.png",
    badgeicon: "https://api.badgr.io/public/assertions/BnYb7BBHS0OGznQWvLAFfw/image",
    badgelink: "https://api.badgr.io/public/assertions/BnYb7BBHS0OGznQWvLAFfw",
    obtained: "12-2024",
    accent: "rgb(101 201 243)",
    tags: [
      "CTF", "Web Exploitation", "General Skills"
    ],
    hidden: true,
  },
  {
    title: "YBN CTF 2024",
    description: "Participated in the YBN CTF 2024 and completed around 20+ challenges.",
    issuer: "YBN",
    logo: "/images/logos/ybn.png",
    badgeicon: "",
    badgelink: "",
    obtained: "11-2024",
    accent: "rgb(255 255 255)",
    tags: [
      "CTF", "Cryptography", "Web Exploitation", "Forensics", "Rev", "Pwn"
    ],
    hidden: true,
  },
  {
    title: "Cyber Sports Challenge 2024",
    description: "Completed 5 Levels and placed 4th overall in the Invitational Category.",
    issuer: "Sentinel Programme",
    logo: "/images/logos/sentinelsg.png",
    badgeicon: "",
    badgelink: "",
    obtained: "11-2024",
    accent: "rgb(125 77 216)",
    tags: [
      "CTF", "Network Analysis", "Rev"
    ],
  },
  {
    title: "BlahajCTF 2024",
    description: "This is the second CTF that I participated in. Completed over 30+ challenges but did not make it to the finals for the non-eligible category.",
    issuer: "BlahajCTF",
    logo: "/images/logos/blahaj.jpg",
    badgeicon: "",
    badgelink: "",
    obtained: "11-2024",
    accent: "rgb(123 169 208)",
    tags: [
      "CTF", "OSINT", "Cryptography", "Web Exploitation", "Forensics", "Rev", "Pwn"
    ],
    hidden: true,
  },
  {
    title: "The InfoSecurity Challenge (TISC) 2024",
    description: "Nearly a year after I entered the world of Cybersecurity, I decided for the first time to participate in a CTF. This was the first CTF that I ever participated in. Completed 1 / 12 challenges.",
    issuer: "Centre for Strategic Infocomm Technologies (CSIT)",
    logo: "/images/logos/csit-logo.png",
    badgeicon: "https://badgr.com/public/assertions/LZXZ6BoISmaFSlNk0Ko12w/image",
    badgelink: "https://badgr.com/public/assertions/LZXZ6BoISmaFSlNk0Ko12w",
    obtained: "10-2024",
    accent: "rgb(72 92 159)",
    tags: [
      "CTF", "OSINT", "Prompt Injection"
    ],
    hidden: true,
  },
  {
    title: "Youth X Hack 2024",
    description: "We are a group of 5 that developed 'UnityLink' that enables vulnerable groups to overcome language or physical barriers to access community networks, increasing and improving their social interactions. This is done by using algorithms to matchmake individuals based on their interest to events. It also facilities travel through volunteering and people while taking notes of their needs or difficulties. Scored a single placement behind the runner up team.",
    issuer: "",
    logo: "",
    badgeicon: "/images/badges/yxh24.png",
    badgelink: "",
    obtained: "09-2024",
    accent: "rgb(226 168 241)",
    tags: [
      "Hackathon",
      "Total Defense",
      "Algorithms"
    ],
    hidden: true,
  },
  // {
  //   title: "",
  //   description: "",
  //   issuer: "",
  //   logo: "",
  //   badgeicon: "",
  //   badgelink: "",
  //   obtained: "",
  //   accent: "rgb(169 67 251)",
  //   tags: [
  //     "CTF",
  //   ],
  // },
]
---

<section class="py-8 px-8 max-md:py-4 mb-4 scroll-m-16 overflow-visible" id="competitions">
  <div class="flex flex-col pt-8 max-w-4xl mx-auto overflow-visible">
    <div class="flex gap-4 items-center justify-center text-center flex-wrap">
      <Icon class="text-3xl dark:text-white text-blacktext max-sm:text-2xl" name="trophy" />
      <Heading text="All" textGradient="Competitions" level={2} />
    </div>

    <div class="mt-6 flex justify-center">
      <button
        id="toggleHiddenComps"
        class="toggle-hidden-btn inline-flex items-center gap-2 rounded-full border border-zinc-300 dark:border-white/20 bg-white/80 dark:bg-zinc-800/80 px-4 py-2 text-sm font-medium text-zinc-700 dark:text-zinc-300 transition-all hover:border-zinc-500 dark:hover:border-white/40 hover:bg-zinc-100 dark:hover:bg-zinc-700 backdrop-blur-sm cursor-pointer group/btn"
        aria-label="Toggle hidden competitions"
      >
        <span class="icon-wrapper">
          <Icon name="eye-off" class="text-lg icon-default transition-opacity duration-200" />
          <Icon name="eye" class="text-lg icon-hover absolute inset-0 opacity-0 transition-opacity duration-200" />
        </span>
        <span>Show Hidden</span>
      </button>
    </div>

    <div class="relative max-md:mt-0 overflow-visible px-4 md:px-0" aria-label="Competition achievements">
      <ol id="competitionsContainer" class="relative mt-10 space-y-6 overflow-visible">
        {
          COMPETITION.map((comp, index) => {
            const CardTag = comp.badgelink ? "a" : "div";
            const isHidden = comp.hidden === true;
            const grayAccent = "rgb(156 163 175)"; // gray-400
            return (
              <li class={`comp-item ${isHidden ? "hidden-comp" : ""} snap-center overflow-visible`} data-hidden={isHidden}>
                <article
                  role="article"
                  aria-labelledby={`comp-title-${index}`}
                  class="relative"
                >
                  <CardTag
                    {...(comp.badgelink
                      ? {
                          href: comp.badgelink,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          "aria-label": `Open ${comp.title} badge`,
                        }
                      : {})}
                    class="group relative rounded-3xl border border-zinc-200/50 dark:border-white/10 bg-white/80 dark:bg-[var(--accent)]/15 backdrop-blur-sm p-6 md:p-8 ring-1 ring-zinc-200/50 dark:ring-white/10 transition-all duration-300 hover:border-[var(--accent-real)]/50 hover:ring-[var(--accent-real)]/50 hover:shadow-[0_0_40px_-5px_var(--accent-blur)] hover:dark:bg-[var(--accent-real)]/15 flex flex-col md:flex-row gap-6 items-center overflow-visible"
                    style={`--accent-real: ${comp.accent || "rgb(56 189 248)"}; --accent: ${isHidden ? grayAccent : comp.accent || "rgb(56 189 248)"}; --accent-blur: color-mix(in srgb, var(--accent-real) 60%, transparent); --accent-light: color-mix(in srgb, var(--accent) 30%, transparent);`}
                  >
                    <div class="absolute inset-0 rounded-3xl overflow-hidden pointer-events-none -z-10">
                    <span
                      aria-hidden="true"
                      class="pointer-events-none absolute inset-0 z-0 opacity-30 group-hover:opacity-40 transition-opacity duration-300"
                    >
                      <span class="absolute inset-0 bg-gradient-to-br from-[var(--accent-light)] via-transparent to-transparent" />
                      <span class="absolute inset-0 bg-gradient-to-tl from-[var(--accent-light)] via-transparent to-transparent opacity-50" />
                    </span>

                    <span
                      aria-hidden="true"
                      class="pointer-events-none absolute inset-0 z-0 opacity-20 group-hover:opacity-60 transition-opacity duration-300"
                      style="background-image: radial-gradient(circle at 2px 2px, var(--accent) 1px, transparent 1px); background-size: 32px 32px;"
                    />

                    <span
                      aria-hidden="true"
                      class="pointer-events-none absolute inset-0 z-0 animate-[spin_25s_linear_infinite] group-hover:animate-[spin_15s_linear_infinite]"
                    >
                      <span class="absolute -top-32 left-1/2 -translate-x-1/2 size-64 rounded-full bg-[radial-gradient(circle_at_center,_var(--accent),_transparent_70%)] opacity-20 blur-3xl group-hover:size-80 group-hover:opacity-50 transition-all duration-700" />
                      
                      <span class="absolute top-1/2 -right-32 -translate-y-1/2 size-72 rounded-full bg-[radial-gradient(circle_at_center,_var(--accent),_transparent_70%)] opacity-25 blur-3xl group-hover:size-88 group-hover:opacity-60 transition-all duration-700" />
                      
                      <span class="absolute -bottom-32 left-1/2 -translate-x-1/2 size-68 rounded-full bg-[radial-gradient(circle_at_center,_var(--accent),_transparent_70%)] opacity-18 blur-3xl group-hover:size-84 group-hover:opacity-55 transition-all duration-700" />
                    </span>

                    <span
                      aria-hidden="true"
                      class="pointer-events-none absolute inset-0 z-0 animate-[spin_20s_linear_infinite_reverse] group-hover:animate-[spin_12s_linear_infinite_reverse]"
                    >
                      <span class="absolute -top-24 -left-24 size-56 rounded-full bg-[radial-gradient(circle_at_center,_var(--accent-blur),_transparent_75%)] opacity-15 blur-3xl group-hover:size-72 group-hover:opacity-45 transition-all duration-700" />
                      
                      <span class="absolute -bottom-24 -right-24 size-60 rounded-full bg-[radial-gradient(circle_at_center,_var(--accent-blur),_transparent_75%)] opacity-20 blur-3xl group-hover:size-76 group-hover:opacity-50 transition-all duration-700" />
                    </span>
                    </div>

                    {(comp.badgeicon || comp.logo) && (
                      <div class="relative shrink-0 z-10">
                        <div class="relative">
                          <img
                            src={comp.badgeicon || comp.logo}
                            alt={`${comp.title} ${comp.badgeicon ? 'badge' : 'logo'}`}
                            class="h-32 w-32 md:h-40 md:w-40 object-contain opacity-95 transition-transform duration-300 group-hover:scale-110 rounded-2xl"
                            loading={index < 2 ? "eager" : "lazy"}
                            fetchpriority={index < 2 ? "high" : "auto"}
                            decoding="async"
                          />
                          {comp.badgeicon && comp.logo && (
                            <img
                              src={comp.logo}
                              alt={`${comp.issuer} logo`}
                              class="absolute -bottom-2 -right-2 h-10 w-10 md:h-12 md:w-12 object-contain drop-shadow-lg bg-white/90 dark:bg-black/90 p-1.5 rounded-lg"
                              loading={index < 2 ? "eager" : "lazy"}
                              fetchpriority={index < 2 ? "high" : "auto"}
                              decoding="async"
                            />
                          )}
                        </div>
                      </div>
                    )}

                    <div class="relative flex-1 z-10 text-center md:text-left">
                      <h3
                        id={`comp-title-${index}`}
                        class="text-xl md:text-2xl font-bold leading-snug mb-2"
                        style="color: var(--accent)"
                      >
                        {comp.title}
                      </h3>
                      
                      <p class="text-sm md:text-base font-medium text-zinc-900 dark:text-white/80 mb-1">
                        {comp.issuer}
                      </p>
                      
                      <p class="text-sm md:text-base text-zinc-700 dark:text-white/70 mb-4">
                        {comp.description}
                      </p>

                      <div class="flex flex-wrap gap-2 justify-center md:justify-start">
                        {comp.tags.map((tag) => (
                          <span
                            class="inline-flex items-center rounded-full px-3 py-1 text-xs font-medium ring-1 ring-inset transition-colors"
                            style={`background-color: color-mix(in srgb, ${isHidden ? "var(--accent-real)" : "var(--accent)"} 20%, transparent); color: ${isHidden ? "var(--accent-real)" : "var(--accent)"}; ring-color: color-mix(in srgb, ${isHidden ? "var(--accent-real)" : "var(--accent)"} 40%, transparent);`}
                          >
                            {tag}
                          </span>
                        ))}
                      </div>

                      {comp.obtained && (
                        <div class="mt-4 flex items-center gap-2 text-xs text-zinc-700 dark:text-white/60 justify-center md:justify-start">
                          <Icon name="calendar" class="w-4 h-4" />
                          <time datetime={comp.obtained}>
                            {new Date(comp.obtained.split('-').reverse().join('-')).toLocaleDateString('en-US', {
                              month: 'long',
                              year: 'numeric'
                            })}
                          </time>
                        </div>
                      )}
                    </div>
                  </CardTag>
                </article>
              </li>
            );
          })
        }
      </ol>
    </div>
  </div>
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const toggleButton = document.getElementById('toggleHiddenComps');
    const hiddenComps = document.querySelectorAll('.hidden-comp');
    let isShowing = false;

    toggleButton?.addEventListener('click', () => {
      isShowing = !isShowing;
      
      hiddenComps.forEach(comp => {
        if (isShowing) {
          comp.classList.add('show');
        } else {
          comp.classList.remove('show');
        }
      });

      // Update button state and text
      const text = toggleButton.querySelector('span:not(.icon-wrapper)');
      
      if (text) {
        if (isShowing) {
          toggleButton.classList.add('active');
          text.textContent = 'Hide Hidden';
        } else {
          toggleButton.classList.remove('active');
          text.textContent = 'Show Hidden';
        }
      }
      
      // Toggle button state for icon swap
      toggleButton.classList.toggle('showing');
    });

    // Mobile scroll-to-center with auto-hover functionality
    const container = document.getElementById('competitionsContainer');
    const section = document.getElementById('competitions');
    
    if (!container || !section) return;

    let scrollTimeout: number | null = null;
    let isUserScrolling = false;
    let isMobile = window.innerWidth < 768;
    let observer: IntersectionObserver | null = null;
    let rafId: number | null = null;

    // Update mobile state on resize
    const updateMobileState = () => {
      const wasMobile = isMobile;
      isMobile = window.innerWidth < 768;
      
      // If switching from desktop to mobile or vice versa, cleanup
      if (wasMobile !== isMobile) {
        cleanup();
        if (isMobile) {
          initMobileScrollBehavior();
        }
      }
    };

    const cleanup = () => {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
        scrollTimeout = null;
      }
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (observer) {
        observer.disconnect();
        observer = null;
      }
      // Remove scroll listener
      window.removeEventListener('scroll', onScroll);
      // Remove all mobile-active classes
      document.querySelectorAll('.comp-item.mobile-active').forEach(item => {
        item.classList.remove('mobile-active');
      });
    };

    const findCenterCard = (): HTMLElement | null => {
      const items = Array.from(container.querySelectorAll('.comp-item:not(.hidden-comp), .comp-item.show')) as HTMLElement[];
      if (items.length === 0) return null;

      // Use viewport center for detection
      const viewportCenter = window.innerHeight / 2;

      // Get bounds of first and last card
      const firstCard = items[0];
      const lastCard = items[items.length - 1];
      const firstRect = firstCard.getBoundingClientRect();
      const lastRect = lastCard.getBoundingClientRect();

      // Check if viewport center is within the range of cards
      const firstCardTop = firstRect.top;
      const lastCardBottom = lastRect.bottom;

      // If viewport center is not within the card list bounds, return null
      if (viewportCenter < firstCardTop || viewportCenter > lastCardBottom) {
        return null;
      }

      let closestItem: HTMLElement | null = null;
      let closestDistance = Infinity;

      items.forEach(item => {
        const rect = item.getBoundingClientRect();
        const itemCenter = rect.top + rect.height / 2;
        const distance = Math.abs(viewportCenter - itemCenter);

        if (distance < closestDistance) {
          closestDistance = distance;
          closestItem = item;
        }
      });

      // Only return the card if it's reasonably close to center (within viewport)
      if (closestItem && closestDistance < window.innerHeight * 0.4) {
        return closestItem;
      }

      return null;
    };

    const scrollToCenter = (item: HTMLElement) => {
      if (!item) return;
      
      const rect = item.getBoundingClientRect();
      const viewportCenter = window.innerHeight / 2;
      const itemCenter = rect.top + rect.height / 2;
      const scrollOffset = itemCenter - viewportCenter;
      
      // Scroll the window, not the container
      window.scrollBy({
        top: scrollOffset,
        behavior: 'smooth'
      });
    };

    const applyHoverEffect = (item: HTMLElement | null) => {
      // Remove hover effect from all items
      document.querySelectorAll('.comp-item.mobile-active').forEach(el => {
        el.classList.remove('mobile-active');
      });

      // Apply to the centered item
      if (item) {
        item.classList.add('mobile-active');
      }
    };

    const handleScrollEnd = () => {
      if (!isMobile) return;

      const centerCard = findCenterCard();
      if (centerCard) {
        // Check if we're actually in the section
        const sectionRect = section.getBoundingClientRect();
        const viewportCenter = window.innerHeight / 2;
        
        // Only auto-scroll if viewport center is within the section bounds
        if (viewportCenter >= sectionRect.top && viewportCenter <= sectionRect.bottom) {
          scrollToCenter(centerCard);
          
          // Keep the hover effect on the card (already applied during scroll)
          setTimeout(() => {
            if (!isUserScrolling) {
              // Re-apply in case the card changed after auto-scroll
              const finalCard = findCenterCard();
              applyHoverEffect(finalCard);
            }
          }, 300);
        }
      }
    };

    const onScroll = () => {
      if (!isMobile) return;
      
      isUserScrolling = true;
      
      // Use requestAnimationFrame for smooth updates
      if (rafId) {
        cancelAnimationFrame(rafId);
      }
      
      rafId = requestAnimationFrame(() => {
        // Apply hover effect immediately to the card closest to center while scrolling
        const centerCard = findCenterCard();
        applyHoverEffect(centerCard);
        rafId = null;
      });

      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      scrollTimeout = window.setTimeout(() => {
        isUserScrolling = false;
        handleScrollEnd();
      }, 150);
    };

    const initMobileScrollBehavior = () => {
      if (!isMobile) return;

      // Set up scroll listener on window for mobile
      window.addEventListener('scroll', onScroll, { passive: true });

      // Set up intersection observer to detect when section is in view
      observer = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            if (!entry.isIntersecting) {
              // Section is not visible, cleanup
              applyHoverEffect(null);
              isUserScrolling = false;
              if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
              }
            } else if (!isUserScrolling) {
              // Section became visible and user is not scrolling
              // Apply effect to center card if exists
              setTimeout(() => {
                const sectionRect = section.getBoundingClientRect();
                const viewportCenter = window.innerHeight / 2;
                
                // Only apply if viewport center is within section
                if (viewportCenter >= sectionRect.top && viewportCenter <= sectionRect.bottom) {
                  const centerCard = findCenterCard();
                  if (centerCard) {
                    applyHoverEffect(centerCard);
                  }
                }
              }, 100);
            }
          });
        },
        {
          threshold: 0.2,
          rootMargin: '-20% 0px -20% 0px'
        }
      );

      observer.observe(section);

      // Initial check
      setTimeout(() => {
        if (!isUserScrolling) {
          const centerCard = findCenterCard();
          if (centerCard) {
            applyHoverEffect(centerCard);
          }
        }
      }, 500);
    };

    // Initialize if mobile
    if (isMobile) {
      initMobileScrollBehavior();
    }

    // Handle resize
    window.addEventListener('resize', updateMobileState);

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
  });
</script>
